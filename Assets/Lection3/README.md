# Дано:

1. Примитивное поле и два юнита
2. Скрипт управления героем

# Задание:

Реализовать поведение NPC с помощью разных подходов:

1. Компонентный. Разбить логику NPC на компоненты
    
    1.1 HealthComponent (хранит HP)

    1.2 MovementComponent (умеет двигаться к точке)

    1.3 AttackComponent (умеет атаковать игрока)


2. FSM. Добавить состояние и переходы между ними

    2.1 Состояния: Idle, FollowPlayer, Attack

    2.2 Логика переходов (если игрок далеко — Idle, ближе — Chase, рядом — Attack)


3. Observer. Создать пример "наблюдателя" за переменной

    3.1 Создать переменную для хранения здоровья NPC 

    3.2 Создать событие OnHealthChanged

    3.3 Добавить метод TakeDamage который уменьшает здоровье при контакте с игроком и вызывает событие

    3.4 Создать вспомогательный класс для отображение здоровья в лог


4. Singleton. Создать простой singleton

    4.1 Хранит количество очков игрока

    4.2 Добавляет очки через публичный метод при контакте с NPC

    4.3 Неразрушаемый


## Задание со звёздочкой:

5. Object Pool. Переиспользование уже созданных объектов вместо Instantiate/Destroy

    5.1 Создать пул объектов пуль

    5.2 Реализовать метод получения пули

    5.3 Реализовать метод возврата пули обратно в пул

    5.4* Продемонстировать как это работает: при нажатии на пробел использовать пули, если попадают в стену то возвращать в пул


6. EventBus. Сделать простую систему событий

    6.1 NPC подписывается на событие "игрок рядом" (когда срабатывает триггер)

    6.2 При событии NPC меняет поведение (например, отпрыгивает на рандомное N расстояние)

    6.3 Игрок подписывается на событие "стена рядом" (когда упирается в стену)

    6.4 При событии игрок меняет размер


7. Command. Сделать систему команд

    7.1 Создать интерфейс команды перемещения игрока и отмены хода

    7.2 Создать класс который реализует этот интерфейс

    7.3* Создать скрипт который демонстрирует работу "истории": перемещение вперед и откат назад


# Что может понадобиться

Состояния можно задавать через Enum, а проверять через Switch
```
public enum MyState { State1, State2, State3... }

switch (currentState) {
    case MyState.State1:
        ...
        break;

    case MyState.State2:
        ...
        break;

    case MyState...:
        break;
}
```

Расстояние между объектами можно вычислить через Vector3.Distance
```
float distance = Vector3.Distance(XXX, YYY);
```

Событие можно задать через Action
```
public event Action MyAction;
```

Для создания очереди можно использовать класс Queue
```
Queue<XXX> poll = new Queue<XXX>();

var item = pool.Dequeue(); // получить из очереди
var pool.Enqueue(XXX); // добавить в очередь
```

Для перехвата нажатий клавиш
```
void Update() {
    if (Input.GetKeyDown(KeyCode.XXXX)) {
        ...
    }
}
```

Работа со стеком
```
Stack<XXX> history = new Stack<XXX>();

history.Push(XXX); // добавить в стек

var XXX = history.Pop(); // получить из стека
```
